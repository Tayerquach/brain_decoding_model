[
    {
        "label": "pickle",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pickle",
        "description": "pickle",
        "detail": "pickle",
        "documentation": {}
    },
    {
        "label": "numpy",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "numpy",
        "description": "numpy",
        "detail": "numpy",
        "documentation": {}
    },
    {
        "label": "tqdm",
        "importPath": "tqdm",
        "description": "tqdm",
        "isExtraImport": true,
        "detail": "tqdm",
        "documentation": {}
    },
    {
        "label": "tqdm",
        "importPath": "tqdm",
        "description": "tqdm",
        "isExtraImport": true,
        "detail": "tqdm",
        "documentation": {}
    },
    {
        "label": "tqdm",
        "importPath": "tqdm",
        "description": "tqdm",
        "isExtraImport": true,
        "detail": "tqdm",
        "documentation": {}
    },
    {
        "label": "tqdm",
        "importPath": "tqdm",
        "description": "tqdm",
        "isExtraImport": true,
        "detail": "tqdm",
        "documentation": {}
    },
    {
        "label": "ttest_1samp",
        "importPath": "scipy.stats",
        "description": "scipy.stats",
        "isExtraImport": true,
        "detail": "scipy.stats",
        "documentation": {}
    },
    {
        "label": "ttest_rel",
        "importPath": "scipy.stats",
        "description": "scipy.stats",
        "isExtraImport": true,
        "detail": "scipy.stats",
        "documentation": {}
    },
    {
        "label": "ttest_1samp",
        "importPath": "scipy.stats",
        "description": "scipy.stats",
        "isExtraImport": true,
        "detail": "scipy.stats",
        "documentation": {}
    },
    {
        "label": "ttest_rel",
        "importPath": "scipy.stats",
        "description": "scipy.stats",
        "isExtraImport": true,
        "detail": "scipy.stats",
        "documentation": {}
    },
    {
        "label": "ttest_rel",
        "importPath": "scipy.stats",
        "description": "scipy.stats",
        "isExtraImport": true,
        "detail": "scipy.stats",
        "documentation": {}
    },
    {
        "label": "bootstrap",
        "importPath": "scipy.stats",
        "description": "scipy.stats",
        "isExtraImport": true,
        "detail": "scipy.stats",
        "documentation": {}
    },
    {
        "label": "ks_2samp",
        "importPath": "scipy.stats",
        "description": "scipy.stats",
        "isExtraImport": true,
        "detail": "scipy.stats",
        "documentation": {}
    },
    {
        "label": "pandas",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pandas",
        "description": "pandas",
        "detail": "pandas",
        "documentation": {}
    },
    {
        "label": "CHANNEL_NAMES",
        "importPath": "utils.config",
        "description": "utils.config",
        "isExtraImport": true,
        "detail": "utils.config",
        "documentation": {}
    },
    {
        "label": "INTERVALS",
        "importPath": "utils.config",
        "description": "utils.config",
        "isExtraImport": true,
        "detail": "utils.config",
        "documentation": {}
    },
    {
        "label": "N_CHANNELS",
        "importPath": "utils.config",
        "description": "utils.config",
        "isExtraImport": true,
        "detail": "utils.config",
        "documentation": {}
    },
    {
        "label": "N_TOPICS",
        "importPath": "utils.config",
        "description": "utils.config",
        "isExtraImport": true,
        "detail": "utils.config",
        "documentation": {}
    },
    {
        "label": "T_MAX",
        "importPath": "utils.config",
        "description": "utils.config",
        "isExtraImport": true,
        "detail": "utils.config",
        "documentation": {}
    },
    {
        "label": "T_MIN",
        "importPath": "utils.config",
        "description": "utils.config",
        "isExtraImport": true,
        "detail": "utils.config",
        "documentation": {}
    },
    {
        "label": "LEFT_HEMISPHERE",
        "importPath": "utils.config",
        "description": "utils.config",
        "isExtraImport": true,
        "detail": "utils.config",
        "documentation": {}
    },
    {
        "label": "RIGHT_HEMISPHERE",
        "importPath": "utils.config",
        "description": "utils.config",
        "isExtraImport": true,
        "detail": "utils.config",
        "documentation": {}
    },
    {
        "label": "MIDLINES",
        "importPath": "utils.config",
        "description": "utils.config",
        "isExtraImport": true,
        "detail": "utils.config",
        "documentation": {}
    },
    {
        "label": "INTERVALS",
        "importPath": "utils.config",
        "description": "utils.config",
        "isExtraImport": true,
        "detail": "utils.config",
        "documentation": {}
    },
    {
        "label": "T_MAX",
        "importPath": "utils.config",
        "description": "utils.config",
        "isExtraImport": true,
        "detail": "utils.config",
        "documentation": {}
    },
    {
        "label": "T_MIN",
        "importPath": "utils.config",
        "description": "utils.config",
        "isExtraImport": true,
        "detail": "utils.config",
        "documentation": {}
    },
    {
        "label": "CHANNEL_NAMES",
        "importPath": "utils.config",
        "description": "utils.config",
        "isExtraImport": true,
        "detail": "utils.config",
        "documentation": {}
    },
    {
        "label": "INTERVALS",
        "importPath": "utils.config",
        "description": "utils.config",
        "isExtraImport": true,
        "detail": "utils.config",
        "documentation": {}
    },
    {
        "label": "T_MAX",
        "importPath": "utils.config",
        "description": "utils.config",
        "isExtraImport": true,
        "detail": "utils.config",
        "documentation": {}
    },
    {
        "label": "T_MIN",
        "importPath": "utils.config",
        "description": "utils.config",
        "isExtraImport": true,
        "detail": "utils.config",
        "documentation": {}
    },
    {
        "label": "best_clusters",
        "importPath": "utils.config",
        "description": "utils.config",
        "isExtraImport": true,
        "detail": "utils.config",
        "documentation": {}
    },
    {
        "label": "CHANNEL_NAMES",
        "importPath": "utils.config",
        "description": "utils.config",
        "isExtraImport": true,
        "detail": "utils.config",
        "documentation": {}
    },
    {
        "label": "INTERVALS",
        "importPath": "utils.config",
        "description": "utils.config",
        "isExtraImport": true,
        "detail": "utils.config",
        "documentation": {}
    },
    {
        "label": "T_MIN",
        "importPath": "utils.config",
        "description": "utils.config",
        "isExtraImport": true,
        "detail": "utils.config",
        "documentation": {}
    },
    {
        "label": "best_clusters",
        "importPath": "utils.config",
        "description": "utils.config",
        "isExtraImport": true,
        "detail": "utils.config",
        "documentation": {}
    },
    {
        "label": "CONTENT_TYPES",
        "importPath": "utils.config",
        "description": "utils.config",
        "isExtraImport": true,
        "detail": "utils.config",
        "documentation": {}
    },
    {
        "label": "EEG_PATH",
        "importPath": "utils.config",
        "description": "utils.config",
        "isExtraImport": true,
        "detail": "utils.config",
        "documentation": {}
    },
    {
        "label": "FUNCTION_TYPES",
        "importPath": "utils.config",
        "description": "utils.config",
        "isExtraImport": true,
        "detail": "utils.config",
        "documentation": {}
    },
    {
        "label": "HIGH_CLOZE",
        "importPath": "utils.config",
        "description": "utils.config",
        "isExtraImport": true,
        "detail": "utils.config",
        "documentation": {}
    },
    {
        "label": "LOW_CLOZE",
        "importPath": "utils.config",
        "description": "utils.config",
        "isExtraImport": true,
        "detail": "utils.config",
        "documentation": {}
    },
    {
        "label": "N_CHANNELS",
        "importPath": "utils.config",
        "description": "utils.config",
        "isExtraImport": true,
        "detail": "utils.config",
        "documentation": {}
    },
    {
        "label": "N_TOPICS",
        "importPath": "utils.config",
        "description": "utils.config",
        "isExtraImport": true,
        "detail": "utils.config",
        "documentation": {}
    },
    {
        "label": "NUM_TIME_POINTS",
        "importPath": "utils.config",
        "description": "utils.config",
        "isExtraImport": true,
        "detail": "utils.config",
        "documentation": {}
    },
    {
        "label": "PREPROCESSED_FOLDER",
        "importPath": "utils.config",
        "description": "utils.config",
        "isExtraImport": true,
        "detail": "utils.config",
        "documentation": {}
    },
    {
        "label": "T_MIN",
        "importPath": "utils.config",
        "description": "utils.config",
        "isExtraImport": true,
        "detail": "utils.config",
        "documentation": {}
    },
    {
        "label": "INTERVALS",
        "importPath": "utils.config",
        "description": "utils.config",
        "isExtraImport": true,
        "detail": "utils.config",
        "documentation": {}
    },
    {
        "label": "CHANNEL_NAMES",
        "importPath": "utils.config",
        "description": "utils.config",
        "isExtraImport": true,
        "detail": "utils.config",
        "documentation": {}
    },
    {
        "label": "best_clusters",
        "importPath": "utils.config",
        "description": "utils.config",
        "isExtraImport": true,
        "detail": "utils.config",
        "documentation": {}
    },
    {
        "label": "SpacyTokenizer",
        "importPath": "ipa.preprocessing.tokenizers.spacy_tokenizer",
        "description": "ipa.preprocessing.tokenizers.spacy_tokenizer",
        "isExtraImport": true,
        "detail": "ipa.preprocessing.tokenizers.spacy_tokenizer",
        "documentation": {}
    },
    {
        "label": "Decimal",
        "importPath": "decimal",
        "description": "decimal",
        "isExtraImport": true,
        "detail": "decimal",
        "documentation": {}
    },
    {
        "label": "os",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "os",
        "description": "os",
        "detail": "os",
        "documentation": {}
    },
    {
        "label": "matplotlib.pyplot",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "matplotlib.pyplot",
        "description": "matplotlib.pyplot",
        "detail": "matplotlib.pyplot",
        "documentation": {}
    },
    {
        "label": "matplotlib.lines",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "matplotlib.lines",
        "description": "matplotlib.lines",
        "detail": "matplotlib.lines",
        "documentation": {}
    },
    {
        "label": "seaborn",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "seaborn",
        "description": "seaborn",
        "detail": "seaborn",
        "documentation": {}
    },
    {
        "label": "PtitPrince",
        "importPath": "ptitprince",
        "description": "ptitprince",
        "isExtraImport": true,
        "detail": "ptitprince",
        "documentation": {}
    },
    {
        "label": "warnings",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "warnings",
        "description": "warnings",
        "detail": "warnings",
        "documentation": {}
    },
    {
        "label": "clusterbased_permutation_1d_1samp_1sided",
        "importPath": "utils.analysis_helpers",
        "description": "utils.analysis_helpers",
        "isExtraImport": true,
        "detail": "utils.analysis_helpers",
        "documentation": {}
    },
    {
        "label": "prepare_data_word_class",
        "importPath": "utils.analysis_helpers",
        "description": "utils.analysis_helpers",
        "isExtraImport": true,
        "detail": "utils.analysis_helpers",
        "documentation": {}
    },
    {
        "label": "prepare_data_word_class",
        "importPath": "utils.analysis_helpers",
        "description": "utils.analysis_helpers",
        "isExtraImport": true,
        "detail": "utils.analysis_helpers",
        "documentation": {}
    },
    {
        "label": "prepare_data_word_class",
        "importPath": "utils.analysis_helpers",
        "description": "utils.analysis_helpers",
        "isExtraImport": true,
        "detail": "utils.analysis_helpers",
        "documentation": {}
    },
    {
        "label": "prepare_data_word_class",
        "importPath": "utils.analysis_helpers",
        "description": "utils.analysis_helpers",
        "isExtraImport": true,
        "detail": "utils.analysis_helpers",
        "documentation": {}
    },
    {
        "label": "prepare_data_word_class",
        "importPath": "utils.analysis_helpers",
        "description": "utils.analysis_helpers",
        "isExtraImport": true,
        "detail": "utils.analysis_helpers",
        "documentation": {}
    },
    {
        "label": "StratifiedKFold",
        "importPath": "sklearn.model_selection",
        "description": "sklearn.model_selection",
        "isExtraImport": true,
        "detail": "sklearn.model_selection",
        "documentation": {}
    },
    {
        "label": "StandardScaler",
        "importPath": "sklearn.preprocessing",
        "description": "sklearn.preprocessing",
        "isExtraImport": true,
        "detail": "sklearn.preprocessing",
        "documentation": {}
    },
    {
        "label": "SVC",
        "importPath": "sklearn.svm",
        "description": "sklearn.svm",
        "isExtraImport": true,
        "detail": "sklearn.svm",
        "documentation": {}
    },
    {
        "label": "permutation_cluster_1samp_test",
        "importPath": "mne.stats",
        "description": "mne.stats",
        "isExtraImport": true,
        "detail": "mne.stats",
        "documentation": {}
    },
    {
        "label": "fdr_correction",
        "importPath": "mne.stats",
        "description": "mne.stats",
        "isExtraImport": true,
        "detail": "mne.stats",
        "documentation": {}
    },
    {
        "label": "permutation_cluster_1samp_test",
        "importPath": "mne.stats",
        "description": "mne.stats",
        "isExtraImport": true,
        "detail": "mne.stats",
        "documentation": {}
    },
    {
        "label": "fdr_correction",
        "importPath": "mne.stats",
        "description": "mne.stats",
        "isExtraImport": true,
        "detail": "mne.stats",
        "documentation": {}
    },
    {
        "label": "argparse",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "argparse",
        "description": "argparse",
        "detail": "argparse",
        "documentation": {}
    },
    {
        "label": "plot_decoding_acc_tbyt",
        "importPath": "utils.plot_helpers",
        "description": "utils.plot_helpers",
        "isExtraImport": true,
        "detail": "utils.plot_helpers",
        "documentation": {}
    },
    {
        "label": "plot_erp_2cons_results",
        "importPath": "utils.plot_helpers",
        "description": "utils.plot_helpers",
        "isExtraImport": true,
        "detail": "utils.plot_helpers",
        "documentation": {}
    },
    {
        "label": "plot_raincloud_diff",
        "importPath": "utils.plot_helpers",
        "description": "utils.plot_helpers",
        "isExtraImport": true,
        "detail": "utils.plot_helpers",
        "documentation": {}
    },
    {
        "label": "plot_raincloud_decoding",
        "importPath": "utils.plot_helpers",
        "description": "utils.plot_helpers",
        "isExtraImport": true,
        "detail": "utils.plot_helpers",
        "documentation": {}
    },
    {
        "label": "classification_decoding_kfold",
        "importPath": "utils.techniques",
        "description": "utils.techniques",
        "isExtraImport": true,
        "detail": "utils.techniques",
        "documentation": {}
    },
    {
        "label": "run_erps_analysis",
        "importPath": "utils.techniques",
        "description": "utils.techniques",
        "isExtraImport": true,
        "detail": "utils.techniques",
        "documentation": {}
    },
    {
        "label": "get_channel_name_ids",
        "importPath": "utils.eeg_helpers",
        "description": "utils.eeg_helpers",
        "isExtraImport": true,
        "detail": "utils.eeg_helpers",
        "documentation": {}
    },
    {
        "label": "get_channel_name_ids",
        "importPath": "utils.eeg_helpers",
        "description": "utils.eeg_helpers",
        "isExtraImport": true,
        "detail": "utils.eeg_helpers",
        "documentation": {}
    },
    {
        "label": "get_channel_name_ids",
        "importPath": "utils.eeg_helpers",
        "description": "utils.eeg_helpers",
        "isExtraImport": true,
        "detail": "utils.eeg_helpers",
        "documentation": {}
    },
    {
        "label": "add_part_of_speech",
        "importPath": "utils.eeg_helpers",
        "description": "utils.eeg_helpers",
        "isExtraImport": true,
        "detail": "utils.eeg_helpers",
        "documentation": {}
    },
    {
        "label": "create_electrodes_data",
        "importPath": "utils.eeg_helpers",
        "description": "utils.eeg_helpers",
        "isExtraImport": true,
        "detail": "utils.eeg_helpers",
        "documentation": {}
    },
    {
        "label": "get_channel_name_ids",
        "importPath": "utils.eeg_helpers",
        "description": "utils.eeg_helpers",
        "isExtraImport": true,
        "detail": "utils.eeg_helpers",
        "documentation": {}
    },
    {
        "label": "Counter",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "mne",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "mne",
        "description": "mne",
        "detail": "mne",
        "documentation": {}
    },
    {
        "label": "prepare_data_word_class",
        "kind": 2,
        "importPath": "utils.analysis_helpers",
        "description": "utils.analysis_helpers",
        "peekOfCode": "def prepare_data_word_class(word_type):\n    '''\n    Import data\n    '''\n    # Read labels to a pickle file\n    with open(f'results/{word_type}/labels.pkl', 'rb') as f:\n        labels = pickle.load(f)\n    # Read EEG_data to a different pickle file\n    with open(f'results/{word_type}/EEG_data.pkl', 'rb') as f:\n        EEG_data = pickle.load(f)",
        "detail": "utils.analysis_helpers",
        "documentation": {}
    },
    {
        "label": "prepare_data_cloze",
        "kind": 2,
        "importPath": "utils.analysis_helpers",
        "description": "utils.analysis_helpers",
        "peekOfCode": "def prepare_data_cloze(cloze_type):\n    '''\n        Import data\n    '''\n    # Read labels for content words\n    with open(f'results/content/labels.pkl', 'rb') as f:\n        labels_content = pickle.load(f)\n    # Read EEG_data for content words\n    with open(f'results/content/EEG_data.pkl', 'rb') as f:\n        EEG_data_content = pickle.load(f)",
        "detail": "utils.analysis_helpers",
        "documentation": {}
    },
    {
        "label": "get_cluster_index_1d_1sided",
        "kind": 2,
        "importPath": "utils.analysis_helpers",
        "description": "utils.analysis_helpers",
        "peekOfCode": "def get_cluster_index_1d_1sided(m):\n    \"\"\"\n    Get 1-D & 1-sided cluster-index information from a vector\n    Parameters\n    ----------\n    m : array\n        A significant vector.\n        The values in m should be 0 or 1, which represent not significant point or significant point, respectively.\n    Returns\n    -------",
        "detail": "utils.analysis_helpers",
        "documentation": {}
    },
    {
        "label": "clusterbased_permutation_1d_1samp_1sided",
        "kind": 2,
        "importPath": "utils.analysis_helpers",
        "description": "utils.analysis_helpers",
        "peekOfCode": "def clusterbased_permutation_1d_1samp_1sided(results, level=0, p_threshold=0.05, clusterp_threshold=0.05, n_threshold=2,\n                                             iter=1000, state=42):\n    \"\"\"\n    1-sample & 1-sided cluster based permutation test for 2-D results\n    Parameters\n    ----------\n    results : array\n        A result matrix.\n        The shape of results should be [n_subs, x]. n_subs represents the number of subjects.\n    level : float. Default is 0.",
        "detail": "utils.analysis_helpers",
        "documentation": {}
    },
    {
        "label": "N_CHANNELS",
        "kind": 5,
        "importPath": "utils.config",
        "description": "utils.config",
        "peekOfCode": "N_CHANNELS = 32\nT_MIN = -0.1\nT_MAX = 0.5\nINTERVALS = 0.001\nNUM_TIME_POINTS = int((T_MAX - T_MIN) / INTERVALS)\nEEG_PATH = 'data/EEG_data'\nPREPROCESSED_FOLDER = 'preprocessed'\nN_TOPICS = 5\nCONTENT_TYPES = ['NOUN','VERB','ADJ','ADV']\nFUNCTION_TYPES = ['PRON','AUX','DET','ADP']",
        "detail": "utils.config",
        "documentation": {}
    },
    {
        "label": "T_MIN",
        "kind": 5,
        "importPath": "utils.config",
        "description": "utils.config",
        "peekOfCode": "T_MIN = -0.1\nT_MAX = 0.5\nINTERVALS = 0.001\nNUM_TIME_POINTS = int((T_MAX - T_MIN) / INTERVALS)\nEEG_PATH = 'data/EEG_data'\nPREPROCESSED_FOLDER = 'preprocessed'\nN_TOPICS = 5\nCONTENT_TYPES = ['NOUN','VERB','ADJ','ADV']\nFUNCTION_TYPES = ['PRON','AUX','DET','ADP']\nHIGH_CLOZE = ['high']",
        "detail": "utils.config",
        "documentation": {}
    },
    {
        "label": "T_MAX",
        "kind": 5,
        "importPath": "utils.config",
        "description": "utils.config",
        "peekOfCode": "T_MAX = 0.5\nINTERVALS = 0.001\nNUM_TIME_POINTS = int((T_MAX - T_MIN) / INTERVALS)\nEEG_PATH = 'data/EEG_data'\nPREPROCESSED_FOLDER = 'preprocessed'\nN_TOPICS = 5\nCONTENT_TYPES = ['NOUN','VERB','ADJ','ADV']\nFUNCTION_TYPES = ['PRON','AUX','DET','ADP']\nHIGH_CLOZE = ['high']\nLOW_CLOZE = ['low']",
        "detail": "utils.config",
        "documentation": {}
    },
    {
        "label": "INTERVALS",
        "kind": 5,
        "importPath": "utils.config",
        "description": "utils.config",
        "peekOfCode": "INTERVALS = 0.001\nNUM_TIME_POINTS = int((T_MAX - T_MIN) / INTERVALS)\nEEG_PATH = 'data/EEG_data'\nPREPROCESSED_FOLDER = 'preprocessed'\nN_TOPICS = 5\nCONTENT_TYPES = ['NOUN','VERB','ADJ','ADV']\nFUNCTION_TYPES = ['PRON','AUX','DET','ADP']\nHIGH_CLOZE = ['high']\nLOW_CLOZE = ['low']\nCHANNEL_NAMES = ['Fp1', 'Fp2', 'F7', 'F3', 'Fz', 'F4', 'F8', 'FC5', 'T7', 'CP5', 'FC6', 'T8', 'CP6', 'FT9', 'FT10', 'FC1', 'FC2', ",
        "detail": "utils.config",
        "documentation": {}
    },
    {
        "label": "NUM_TIME_POINTS",
        "kind": 5,
        "importPath": "utils.config",
        "description": "utils.config",
        "peekOfCode": "NUM_TIME_POINTS = int((T_MAX - T_MIN) / INTERVALS)\nEEG_PATH = 'data/EEG_data'\nPREPROCESSED_FOLDER = 'preprocessed'\nN_TOPICS = 5\nCONTENT_TYPES = ['NOUN','VERB','ADJ','ADV']\nFUNCTION_TYPES = ['PRON','AUX','DET','ADP']\nHIGH_CLOZE = ['high']\nLOW_CLOZE = ['low']\nCHANNEL_NAMES = ['Fp1', 'Fp2', 'F7', 'F3', 'Fz', 'F4', 'F8', 'FC5', 'T7', 'CP5', 'FC6', 'T8', 'CP6', 'FT9', 'FT10', 'FC1', 'FC2', \n'C3', 'Cz', 'C4', 'P3', 'P7', 'CP1', 'CP2', 'Pz', 'P4', 'P8', 'O1', 'Oz', 'O2', 'TP9', 'TP10']",
        "detail": "utils.config",
        "documentation": {}
    },
    {
        "label": "EEG_PATH",
        "kind": 5,
        "importPath": "utils.config",
        "description": "utils.config",
        "peekOfCode": "EEG_PATH = 'data/EEG_data'\nPREPROCESSED_FOLDER = 'preprocessed'\nN_TOPICS = 5\nCONTENT_TYPES = ['NOUN','VERB','ADJ','ADV']\nFUNCTION_TYPES = ['PRON','AUX','DET','ADP']\nHIGH_CLOZE = ['high']\nLOW_CLOZE = ['low']\nCHANNEL_NAMES = ['Fp1', 'Fp2', 'F7', 'F3', 'Fz', 'F4', 'F8', 'FC5', 'T7', 'CP5', 'FC6', 'T8', 'CP6', 'FT9', 'FT10', 'FC1', 'FC2', \n'C3', 'Cz', 'C4', 'P3', 'P7', 'CP1', 'CP2', 'Pz', 'P4', 'P8', 'O1', 'Oz', 'O2', 'TP9', 'TP10']\nLEFT_HEMISPHERE = ['Fp1', 'F7', 'F3', 'FC5', 'T7', 'CP5', 'FT9', 'FC1', 'C3', 'P3', 'P7', 'CP1', 'O1', 'TP9']",
        "detail": "utils.config",
        "documentation": {}
    },
    {
        "label": "PREPROCESSED_FOLDER",
        "kind": 5,
        "importPath": "utils.config",
        "description": "utils.config",
        "peekOfCode": "PREPROCESSED_FOLDER = 'preprocessed'\nN_TOPICS = 5\nCONTENT_TYPES = ['NOUN','VERB','ADJ','ADV']\nFUNCTION_TYPES = ['PRON','AUX','DET','ADP']\nHIGH_CLOZE = ['high']\nLOW_CLOZE = ['low']\nCHANNEL_NAMES = ['Fp1', 'Fp2', 'F7', 'F3', 'Fz', 'F4', 'F8', 'FC5', 'T7', 'CP5', 'FC6', 'T8', 'CP6', 'FT9', 'FT10', 'FC1', 'FC2', \n'C3', 'Cz', 'C4', 'P3', 'P7', 'CP1', 'CP2', 'Pz', 'P4', 'P8', 'O1', 'Oz', 'O2', 'TP9', 'TP10']\nLEFT_HEMISPHERE = ['Fp1', 'F7', 'F3', 'FC5', 'T7', 'CP5', 'FT9', 'FC1', 'C3', 'P3', 'P7', 'CP1', 'O1', 'TP9']\nRIGHT_HEMISPHERE = ['Fp2', 'F4', 'F8', 'FC6', 'T8', 'CP6', 'FT10', 'FC2', 'C4', 'CP2', 'P4', 'P8', 'O2', 'TP10']",
        "detail": "utils.config",
        "documentation": {}
    },
    {
        "label": "N_TOPICS",
        "kind": 5,
        "importPath": "utils.config",
        "description": "utils.config",
        "peekOfCode": "N_TOPICS = 5\nCONTENT_TYPES = ['NOUN','VERB','ADJ','ADV']\nFUNCTION_TYPES = ['PRON','AUX','DET','ADP']\nHIGH_CLOZE = ['high']\nLOW_CLOZE = ['low']\nCHANNEL_NAMES = ['Fp1', 'Fp2', 'F7', 'F3', 'Fz', 'F4', 'F8', 'FC5', 'T7', 'CP5', 'FC6', 'T8', 'CP6', 'FT9', 'FT10', 'FC1', 'FC2', \n'C3', 'Cz', 'C4', 'P3', 'P7', 'CP1', 'CP2', 'Pz', 'P4', 'P8', 'O1', 'Oz', 'O2', 'TP9', 'TP10']\nLEFT_HEMISPHERE = ['Fp1', 'F7', 'F3', 'FC5', 'T7', 'CP5', 'FT9', 'FC1', 'C3', 'P3', 'P7', 'CP1', 'O1', 'TP9']\nRIGHT_HEMISPHERE = ['Fp2', 'F4', 'F8', 'FC6', 'T8', 'CP6', 'FT10', 'FC2', 'C4', 'CP2', 'P4', 'P8', 'O2', 'TP10']\nMIDLINES = ['Fz', 'Cz', 'Pz', 'Oz']",
        "detail": "utils.config",
        "documentation": {}
    },
    {
        "label": "CONTENT_TYPES",
        "kind": 5,
        "importPath": "utils.config",
        "description": "utils.config",
        "peekOfCode": "CONTENT_TYPES = ['NOUN','VERB','ADJ','ADV']\nFUNCTION_TYPES = ['PRON','AUX','DET','ADP']\nHIGH_CLOZE = ['high']\nLOW_CLOZE = ['low']\nCHANNEL_NAMES = ['Fp1', 'Fp2', 'F7', 'F3', 'Fz', 'F4', 'F8', 'FC5', 'T7', 'CP5', 'FC6', 'T8', 'CP6', 'FT9', 'FT10', 'FC1', 'FC2', \n'C3', 'Cz', 'C4', 'P3', 'P7', 'CP1', 'CP2', 'Pz', 'P4', 'P8', 'O1', 'Oz', 'O2', 'TP9', 'TP10']\nLEFT_HEMISPHERE = ['Fp1', 'F7', 'F3', 'FC5', 'T7', 'CP5', 'FT9', 'FC1', 'C3', 'P3', 'P7', 'CP1', 'O1', 'TP9']\nRIGHT_HEMISPHERE = ['Fp2', 'F4', 'F8', 'FC6', 'T8', 'CP6', 'FT10', 'FC2', 'C4', 'CP2', 'P4', 'P8', 'O2', 'TP10']\nMIDLINES = ['Fz', 'Cz', 'Pz', 'Oz']\nbest_clusters = {",
        "detail": "utils.config",
        "documentation": {}
    },
    {
        "label": "FUNCTION_TYPES",
        "kind": 5,
        "importPath": "utils.config",
        "description": "utils.config",
        "peekOfCode": "FUNCTION_TYPES = ['PRON','AUX','DET','ADP']\nHIGH_CLOZE = ['high']\nLOW_CLOZE = ['low']\nCHANNEL_NAMES = ['Fp1', 'Fp2', 'F7', 'F3', 'Fz', 'F4', 'F8', 'FC5', 'T7', 'CP5', 'FC6', 'T8', 'CP6', 'FT9', 'FT10', 'FC1', 'FC2', \n'C3', 'Cz', 'C4', 'P3', 'P7', 'CP1', 'CP2', 'Pz', 'P4', 'P8', 'O1', 'Oz', 'O2', 'TP9', 'TP10']\nLEFT_HEMISPHERE = ['Fp1', 'F7', 'F3', 'FC5', 'T7', 'CP5', 'FT9', 'FC1', 'C3', 'P3', 'P7', 'CP1', 'O1', 'TP9']\nRIGHT_HEMISPHERE = ['Fp2', 'F4', 'F8', 'FC6', 'T8', 'CP6', 'FT10', 'FC2', 'C4', 'CP2', 'P4', 'P8', 'O2', 'TP10']\nMIDLINES = ['Fz', 'Cz', 'Pz', 'Oz']\nbest_clusters = {\n    \"content_selected_chans\": ['P3', 'P7', 'CP1', 'Fp1', 'F7', 'F3', 'FC5', 'T7', 'CP5', 'Cz', 'Pz', 'Oz', 'Fz', 'T8', 'CP6'],",
        "detail": "utils.config",
        "documentation": {}
    },
    {
        "label": "HIGH_CLOZE",
        "kind": 5,
        "importPath": "utils.config",
        "description": "utils.config",
        "peekOfCode": "HIGH_CLOZE = ['high']\nLOW_CLOZE = ['low']\nCHANNEL_NAMES = ['Fp1', 'Fp2', 'F7', 'F3', 'Fz', 'F4', 'F8', 'FC5', 'T7', 'CP5', 'FC6', 'T8', 'CP6', 'FT9', 'FT10', 'FC1', 'FC2', \n'C3', 'Cz', 'C4', 'P3', 'P7', 'CP1', 'CP2', 'Pz', 'P4', 'P8', 'O1', 'Oz', 'O2', 'TP9', 'TP10']\nLEFT_HEMISPHERE = ['Fp1', 'F7', 'F3', 'FC5', 'T7', 'CP5', 'FT9', 'FC1', 'C3', 'P3', 'P7', 'CP1', 'O1', 'TP9']\nRIGHT_HEMISPHERE = ['Fp2', 'F4', 'F8', 'FC6', 'T8', 'CP6', 'FT10', 'FC2', 'C4', 'CP2', 'P4', 'P8', 'O2', 'TP10']\nMIDLINES = ['Fz', 'Cz', 'Pz', 'Oz']\nbest_clusters = {\n    \"content_selected_chans\": ['P3', 'P7', 'CP1', 'Fp1', 'F7', 'F3', 'FC5', 'T7', 'CP5', 'Cz', 'Pz', 'Oz', 'Fz', 'T8', 'CP6'],\n    \"function_selected_chans\": ['Fp1', 'F7', 'F3', 'FC5', 'T7', 'CP5', 'Cz', 'Pz', 'Oz', 'Fp2', 'F4'],",
        "detail": "utils.config",
        "documentation": {}
    },
    {
        "label": "LOW_CLOZE",
        "kind": 5,
        "importPath": "utils.config",
        "description": "utils.config",
        "peekOfCode": "LOW_CLOZE = ['low']\nCHANNEL_NAMES = ['Fp1', 'Fp2', 'F7', 'F3', 'Fz', 'F4', 'F8', 'FC5', 'T7', 'CP5', 'FC6', 'T8', 'CP6', 'FT9', 'FT10', 'FC1', 'FC2', \n'C3', 'Cz', 'C4', 'P3', 'P7', 'CP1', 'CP2', 'Pz', 'P4', 'P8', 'O1', 'Oz', 'O2', 'TP9', 'TP10']\nLEFT_HEMISPHERE = ['Fp1', 'F7', 'F3', 'FC5', 'T7', 'CP5', 'FT9', 'FC1', 'C3', 'P3', 'P7', 'CP1', 'O1', 'TP9']\nRIGHT_HEMISPHERE = ['Fp2', 'F4', 'F8', 'FC6', 'T8', 'CP6', 'FT10', 'FC2', 'C4', 'CP2', 'P4', 'P8', 'O2', 'TP10']\nMIDLINES = ['Fz', 'Cz', 'Pz', 'Oz']\nbest_clusters = {\n    \"content_selected_chans\": ['P3', 'P7', 'CP1', 'Fp1', 'F7', 'F3', 'FC5', 'T7', 'CP5', 'Cz', 'Pz', 'Oz', 'Fz', 'T8', 'CP6'],\n    \"function_selected_chans\": ['Fp1', 'F7', 'F3', 'FC5', 'T7', 'CP5', 'Cz', 'Pz', 'Oz', 'Fp2', 'F4'],\n    \"NOUN_selected_chans\": ['P3', 'P7', 'CP1', 'O1', 'Cz', 'Pz', 'Oz', 'Fz', 'C4', 'CP2', 'P4'],",
        "detail": "utils.config",
        "documentation": {}
    },
    {
        "label": "CHANNEL_NAMES",
        "kind": 5,
        "importPath": "utils.config",
        "description": "utils.config",
        "peekOfCode": "CHANNEL_NAMES = ['Fp1', 'Fp2', 'F7', 'F3', 'Fz', 'F4', 'F8', 'FC5', 'T7', 'CP5', 'FC6', 'T8', 'CP6', 'FT9', 'FT10', 'FC1', 'FC2', \n'C3', 'Cz', 'C4', 'P3', 'P7', 'CP1', 'CP2', 'Pz', 'P4', 'P8', 'O1', 'Oz', 'O2', 'TP9', 'TP10']\nLEFT_HEMISPHERE = ['Fp1', 'F7', 'F3', 'FC5', 'T7', 'CP5', 'FT9', 'FC1', 'C3', 'P3', 'P7', 'CP1', 'O1', 'TP9']\nRIGHT_HEMISPHERE = ['Fp2', 'F4', 'F8', 'FC6', 'T8', 'CP6', 'FT10', 'FC2', 'C4', 'CP2', 'P4', 'P8', 'O2', 'TP10']\nMIDLINES = ['Fz', 'Cz', 'Pz', 'Oz']\nbest_clusters = {\n    \"content_selected_chans\": ['P3', 'P7', 'CP1', 'Fp1', 'F7', 'F3', 'FC5', 'T7', 'CP5', 'Cz', 'Pz', 'Oz', 'Fz', 'T8', 'CP6'],\n    \"function_selected_chans\": ['Fp1', 'F7', 'F3', 'FC5', 'T7', 'CP5', 'Cz', 'Pz', 'Oz', 'Fp2', 'F4'],\n    \"NOUN_selected_chans\": ['P3', 'P7', 'CP1', 'O1', 'Cz', 'Pz', 'Oz', 'Fz', 'C4', 'CP2', 'P4'],\n    \"VERB_selected_chans\": ['P3', 'P7', 'CP1', 'O1', 'FC5', 'T7', 'CP5', 'Cz', 'Pz', 'Oz', 'T8', 'CP6'],",
        "detail": "utils.config",
        "documentation": {}
    },
    {
        "label": "LEFT_HEMISPHERE",
        "kind": 5,
        "importPath": "utils.config",
        "description": "utils.config",
        "peekOfCode": "LEFT_HEMISPHERE = ['Fp1', 'F7', 'F3', 'FC5', 'T7', 'CP5', 'FT9', 'FC1', 'C3', 'P3', 'P7', 'CP1', 'O1', 'TP9']\nRIGHT_HEMISPHERE = ['Fp2', 'F4', 'F8', 'FC6', 'T8', 'CP6', 'FT10', 'FC2', 'C4', 'CP2', 'P4', 'P8', 'O2', 'TP10']\nMIDLINES = ['Fz', 'Cz', 'Pz', 'Oz']\nbest_clusters = {\n    \"content_selected_chans\": ['P3', 'P7', 'CP1', 'Fp1', 'F7', 'F3', 'FC5', 'T7', 'CP5', 'Cz', 'Pz', 'Oz', 'Fz', 'T8', 'CP6'],\n    \"function_selected_chans\": ['Fp1', 'F7', 'F3', 'FC5', 'T7', 'CP5', 'Cz', 'Pz', 'Oz', 'Fp2', 'F4'],\n    \"NOUN_selected_chans\": ['P3', 'P7', 'CP1', 'O1', 'Cz', 'Pz', 'Oz', 'Fz', 'C4', 'CP2', 'P4'],\n    \"VERB_selected_chans\": ['P3', 'P7', 'CP1', 'O1', 'FC5', 'T7', 'CP5', 'Cz', 'Pz', 'Oz', 'T8', 'CP6'],\n    \"DET_selected_chans\": ['FT9', 'FC1', 'C3', 'P3', 'P7', 'CP1', 'Fp1', 'F7', 'F3', 'FC5', 'T7', 'CP5', 'Cz', 'Pz', 'FT10', 'FC2', 'C4', 'CP2', 'Fp2', 'F4', 'F8'],\n    \"PRON_selected_chans\": ['Fp1', 'F7', 'F3', 'FC5', 'T7', 'CP5', 'FT9', 'FC1', 'C3', 'P3', 'P7', 'CP1', 'O1', 'TP9', 'Fz', 'Cz', 'Pz', 'Oz', 'T8', 'CP6'],",
        "detail": "utils.config",
        "documentation": {}
    },
    {
        "label": "RIGHT_HEMISPHERE",
        "kind": 5,
        "importPath": "utils.config",
        "description": "utils.config",
        "peekOfCode": "RIGHT_HEMISPHERE = ['Fp2', 'F4', 'F8', 'FC6', 'T8', 'CP6', 'FT10', 'FC2', 'C4', 'CP2', 'P4', 'P8', 'O2', 'TP10']\nMIDLINES = ['Fz', 'Cz', 'Pz', 'Oz']\nbest_clusters = {\n    \"content_selected_chans\": ['P3', 'P7', 'CP1', 'Fp1', 'F7', 'F3', 'FC5', 'T7', 'CP5', 'Cz', 'Pz', 'Oz', 'Fz', 'T8', 'CP6'],\n    \"function_selected_chans\": ['Fp1', 'F7', 'F3', 'FC5', 'T7', 'CP5', 'Cz', 'Pz', 'Oz', 'Fp2', 'F4'],\n    \"NOUN_selected_chans\": ['P3', 'P7', 'CP1', 'O1', 'Cz', 'Pz', 'Oz', 'Fz', 'C4', 'CP2', 'P4'],\n    \"VERB_selected_chans\": ['P3', 'P7', 'CP1', 'O1', 'FC5', 'T7', 'CP5', 'Cz', 'Pz', 'Oz', 'T8', 'CP6'],\n    \"DET_selected_chans\": ['FT9', 'FC1', 'C3', 'P3', 'P7', 'CP1', 'Fp1', 'F7', 'F3', 'FC5', 'T7', 'CP5', 'Cz', 'Pz', 'FT10', 'FC2', 'C4', 'CP2', 'Fp2', 'F4', 'F8'],\n    \"PRON_selected_chans\": ['Fp1', 'F7', 'F3', 'FC5', 'T7', 'CP5', 'FT9', 'FC1', 'C3', 'P3', 'P7', 'CP1', 'O1', 'TP9', 'Fz', 'Cz', 'Pz', 'Oz', 'T8', 'CP6'],\n}",
        "detail": "utils.config",
        "documentation": {}
    },
    {
        "label": "MIDLINES",
        "kind": 5,
        "importPath": "utils.config",
        "description": "utils.config",
        "peekOfCode": "MIDLINES = ['Fz', 'Cz', 'Pz', 'Oz']\nbest_clusters = {\n    \"content_selected_chans\": ['P3', 'P7', 'CP1', 'Fp1', 'F7', 'F3', 'FC5', 'T7', 'CP5', 'Cz', 'Pz', 'Oz', 'Fz', 'T8', 'CP6'],\n    \"function_selected_chans\": ['Fp1', 'F7', 'F3', 'FC5', 'T7', 'CP5', 'Cz', 'Pz', 'Oz', 'Fp2', 'F4'],\n    \"NOUN_selected_chans\": ['P3', 'P7', 'CP1', 'O1', 'Cz', 'Pz', 'Oz', 'Fz', 'C4', 'CP2', 'P4'],\n    \"VERB_selected_chans\": ['P3', 'P7', 'CP1', 'O1', 'FC5', 'T7', 'CP5', 'Cz', 'Pz', 'Oz', 'T8', 'CP6'],\n    \"DET_selected_chans\": ['FT9', 'FC1', 'C3', 'P3', 'P7', 'CP1', 'Fp1', 'F7', 'F3', 'FC5', 'T7', 'CP5', 'Cz', 'Pz', 'FT10', 'FC2', 'C4', 'CP2', 'Fp2', 'F4', 'F8'],\n    \"PRON_selected_chans\": ['Fp1', 'F7', 'F3', 'FC5', 'T7', 'CP5', 'FT9', 'FC1', 'C3', 'P3', 'P7', 'CP1', 'O1', 'TP9', 'Fz', 'Cz', 'Pz', 'Oz', 'T8', 'CP6'],\n}",
        "detail": "utils.config",
        "documentation": {}
    },
    {
        "label": "best_clusters",
        "kind": 5,
        "importPath": "utils.config",
        "description": "utils.config",
        "peekOfCode": "best_clusters = {\n    \"content_selected_chans\": ['P3', 'P7', 'CP1', 'Fp1', 'F7', 'F3', 'FC5', 'T7', 'CP5', 'Cz', 'Pz', 'Oz', 'Fz', 'T8', 'CP6'],\n    \"function_selected_chans\": ['Fp1', 'F7', 'F3', 'FC5', 'T7', 'CP5', 'Cz', 'Pz', 'Oz', 'Fp2', 'F4'],\n    \"NOUN_selected_chans\": ['P3', 'P7', 'CP1', 'O1', 'Cz', 'Pz', 'Oz', 'Fz', 'C4', 'CP2', 'P4'],\n    \"VERB_selected_chans\": ['P3', 'P7', 'CP1', 'O1', 'FC5', 'T7', 'CP5', 'Cz', 'Pz', 'Oz', 'T8', 'CP6'],\n    \"DET_selected_chans\": ['FT9', 'FC1', 'C3', 'P3', 'P7', 'CP1', 'Fp1', 'F7', 'F3', 'FC5', 'T7', 'CP5', 'Cz', 'Pz', 'FT10', 'FC2', 'C4', 'CP2', 'Fp2', 'F4', 'F8'],\n    \"PRON_selected_chans\": ['Fp1', 'F7', 'F3', 'FC5', 'T7', 'CP5', 'FT9', 'FC1', 'C3', 'P3', 'P7', 'CP1', 'O1', 'TP9', 'Fz', 'Cz', 'Pz', 'Oz', 'T8', 'CP6'],\n}",
        "detail": "utils.config",
        "documentation": {}
    },
    {
        "label": "add_part_of_speech",
        "kind": 2,
        "importPath": "utils.eeg_helpers",
        "description": "utils.eeg_helpers",
        "peekOfCode": "def add_part_of_speech(topic_id):\n    # Initialize metadata as an empty dictionary\n    metadata_dict = {\n        'word_id': [],\n        'pos': []\n    }\n    # Part of Speech\n    spacy_tokenizer = SpacyTokenizer(language=\"en\", return_pos_tags=True, return_lemmas=True)\n    with open(f'data/article/article_{topic_id}.pkl', 'rb') as f:\n        word_stimulus = pickle.load(f)",
        "detail": "utils.eeg_helpers",
        "documentation": {}
    },
    {
        "label": "create_electrodes_data",
        "kind": 2,
        "importPath": "utils.eeg_helpers",
        "description": "utils.eeg_helpers",
        "peekOfCode": "def create_electrodes_data(epochs):\n    \"\"\"\n    This code will change epochs data to a dataframe.\n    Parameters\n    ----------\n    epochs: Epochs object\n    Returns\n    -------\n    merged_df: EEG dataframe\n    metadata: dataframe",
        "detail": "utils.eeg_helpers",
        "documentation": {}
    },
    {
        "label": "get_channel_name_ids",
        "kind": 2,
        "importPath": "utils.eeg_helpers",
        "description": "utils.eeg_helpers",
        "peekOfCode": "def get_channel_name_ids(name):\n    # Define mappings for regions\n    region_map = {\n        \"all\": CHANNEL_NAMES,\n        \"left_hemisphere\": LEFT_HEMISPHERE,\n        \"right_hemisphere\": RIGHT_HEMISPHERE,\n        \"midlines\": MIDLINES,\n    }\n    # Handle special cases\n    if name == \"all\":",
        "detail": "utils.eeg_helpers",
        "documentation": {}
    },
    {
        "label": "plot_erp_2cons_results",
        "kind": 2,
        "importPath": "utils.plot_helpers",
        "description": "utils.plot_helpers",
        "peekOfCode": "def plot_erp_2cons_results(p_vals, avg1, err1, avg2, err2, times, con_labels=['Condition1', 'Condition2'], ylim=[-6, 6], p_threshold=0.05, labelpad=0, cluster_permutation=False):\n    \"\"\"\n    Visualize joint ERPs for two conditions together\n    Parameters\n    ----------\n    times: an array with the shape [n_times]\n    corresponding to the time-points and the range of x-axis\n    con_labels: a list or array with the labels of two conditions,\n    default ['Condition 1', 'Condition 2']\n    ylim: the lims of y-axis, default [-10, 10]",
        "detail": "utils.plot_helpers",
        "documentation": {}
    },
    {
        "label": "plot_decoding_acc_tbyt",
        "kind": 2,
        "importPath": "utils.plot_helpers",
        "description": "utils.plot_helpers",
        "peekOfCode": "def plot_decoding_acc_tbyt(acc, start_time=0, end_time=1, time_interval=0.01, chance=0.5, p=0.05, cluster_permutation=False,\n                           clusterp=0.05, iter=1000, stats_time=[0, 1], color='green', xlim=[0, 1], ylim=[0.4, 0.8],\n                           xlabel='Time (s)', ylabel='Decoding Accuracy', figsize=[13, 8], x0=0, labelpad=0,\n                           ticksize=16, fontsize=25, title=None, title_fontsize=25, sigshow=True, avgshow=True):\n    \"\"\"\n    Plot the time-by-time decoding accuracies\n    Parameters\n    ----------\n    acc : array\n        The decoding accuracies.",
        "detail": "utils.plot_helpers",
        "documentation": {}
    },
    {
        "label": "plot_raincloud_diff",
        "kind": 2,
        "importPath": "utils.plot_helpers",
        "description": "utils.plot_helpers",
        "peekOfCode": "def plot_raincloud_diff(df, group):\n    output_folder = f'photo/raincloud/{group}'\n    # Check if the folder exists, if not create it\n    if not os.path.exists(output_folder):\n        os.makedirs(output_folder)\n    # Rainclouds with FacetGrid according to conditions separately (including three regions) \n    g = sns.FacetGrid(df, col = \"Condition\", height = 6)\n    g = g.map_dataframe(pt.RainCloud, x = \"Region\", y = \"Diff_amp\", data = df, bw = 0.2, width_box = .2, point_size = 1,\n                    width_viol = 0.5, orient = \"v\", pointplot = True)\n    # Adjust the space between the graphs",
        "detail": "utils.plot_helpers",
        "documentation": {}
    },
    {
        "label": "plot_raincloud_decoding",
        "kind": 2,
        "importPath": "utils.plot_helpers",
        "description": "utils.plot_helpers",
        "peekOfCode": "def plot_raincloud_decoding(df, group):\n    output_folder = f'photo/raincloud/{group}'\n    # Check if the folder exists, if not create it\n    if not os.path.exists(output_folder):\n        os.makedirs(output_folder)\n    # Rainclouds with FacetGrid according to conditions\n    g = sns.FacetGrid(df, col = \"Condition\", height = 6)\n    g = g.map_dataframe(pt.RainCloud, x = \"Region\", y = \"Accuracy\", data = df, bw = 0.2, width_box = .2, point_size = 1,\n                    width_viol = 0.5, orient = \"v\", pointplot = True)\n    # Adjust the space between the graphs",
        "detail": "utils.plot_helpers",
        "documentation": {}
    },
    {
        "label": "run_erps_analysis",
        "kind": 2,
        "importPath": "utils.techniques",
        "description": "utils.techniques",
        "peekOfCode": "def run_erps_analysis(erp1, erp2, cluster_permutation=False, clusterp=0.05, iter=1000, state=42):\n    \"\"\"\n    T-test\n    ====\n    Statistical technique for ERPs analysis\n    Parameters\n    ----------\n    erp1: a matrix with the shape [n_subs, n_times]\n    corresponding to all subjects' ERPs under condition 1\n    erp2: a matrix with the shape [n_subs, n_times]",
        "detail": "utils.techniques",
        "documentation": {}
    },
    {
        "label": "smooth_1d",
        "kind": 2,
        "importPath": "utils.techniques",
        "description": "utils.techniques",
        "peekOfCode": "def smooth_1d(x, n=5):\n    \"\"\"\n    smoothing for 1-D results\n    Parameters\n    ----------\n    x : array\n        The results.\n        The shape of x should be [n_sub, n_ts]. n_subs, n_ts represent the number of subjects and the number of\n        time-points.\n    n : int. Default is 5.",
        "detail": "utils.techniques",
        "documentation": {}
    },
    {
        "label": "classification_decoding_kfold",
        "kind": 2,
        "importPath": "utils.techniques",
        "description": "utils.techniques",
        "peekOfCode": "def classification_decoding_kfold(data, labels, n_class, time_win=1, time_step=1, n_avg=None, n_folds=5, n_repeats=2, normalization=False, smooth=True, state=42):\n    \"\"\"\n    Conduct time-by-time decoding for EEG-like data (cross validation)\n    Parameters\n    ----------\n    data : array\n        The neural data.\n        The shape of data must be [n_subs, n_trials, n_chls, n_ts]. n_subs, n_trials, n_chls and n_ts represent the\n        number of subjects, the number of trails, the number of channels and the number of time-points.\n    labels : array",
        "detail": "utils.techniques",
        "documentation": {}
    },
    {
        "label": "create_data",
        "kind": 2,
        "importPath": "extract_optimal_channels",
        "description": "extract_optimal_channels",
        "peekOfCode": "def create_data(word_type, name_region):\n    ## Region\n    indices_region, region_channel_names =  get_channel_name_ids(name_region)\n    EEG_data_class, labels_class = prepare_data_word_class(word_type)\n    EEG_data_region = EEG_data_class[:,:, indices_region, :] * 1e6\n    # EEG_high_cloze will contain columns of data where the corresponding label is 0\n    EEG_high_cloze = EEG_data_region[:, labels_class[0] == 0, :, :]\n    EEG_high_cloze_400 = EEG_high_cloze[:, :, :, 400:]\n    # EEG_low_cloze will contain columns of data where the corresponding label is 1\n    EEG_low_cloze = EEG_data_region[:, labels_class[0] == 1, :, :]",
        "detail": "extract_optimal_channels",
        "documentation": {}
    },
    {
        "label": "run_permutation_test",
        "kind": 2,
        "importPath": "extract_optimal_channels",
        "description": "extract_optimal_channels",
        "peekOfCode": "def run_permutation_test(ERP1, ERP2, name_region):\n    n_subjects, n_sensors, n_timepoints = ERP1.shape\n    indices_region, region_channel_names =  get_channel_name_ids(name_region)\n    # Calculate the difference between the two conditions\n    data_diff = ERP1 - ERP2\n    # Reshape the data_diff for cluster-based permutation testing\n    data_diff = data_diff.reshape(n_subjects, n_sensors * n_timepoints)\n    # Perform the cluster-based permutation test\n    T_obs, clusters, cluster_p_values, H0 = permutation_cluster_1samp_test(\n        data_diff, n_permutations=10000, threshold=0.05, tail=0, n_jobs=1, seed=42, ",
        "detail": "extract_optimal_channels",
        "documentation": {}
    },
    {
        "label": "get_time_window",
        "kind": 2,
        "importPath": "run_cohen_dz",
        "description": "run_cohen_dz",
        "peekOfCode": "def get_time_window(start_idx, end_idx):\n    \"\"\"\n    Adjusts the given indices based on T_MIN, T_MAX, and INTERVALS.\n    Args:\n        start_idx (int): Start time window\n        end_idx (int):End time window\n        t_min (float): Minimum time value (e.g., -0.1).\n        t_max (float): Maximum time value (e.g., 0.5).\n        interval (float): Time interval step (e.g., 0.001).\n    Returns:",
        "detail": "run_cohen_dz",
        "documentation": {}
    },
    {
        "label": "prepare_data_diff",
        "kind": 2,
        "importPath": "run_cohen_dz",
        "description": "run_cohen_dz",
        "peekOfCode": "def prepare_data_diff(category):\n    '''\n        Import data\n    '''\n    EEG_data, labels = prepare_data_word_class(category)   \n    # Regions\n    best_channels = best_clusters[f'{category}_selected_chans']\n    best_indices = [i for i, value in enumerate(CHANNEL_NAMES) if value in(best_channels)]\n    # EEG_data\n    EEG_data_region = EEG_data[:,:, best_indices, :] * 1e6",
        "detail": "run_cohen_dz",
        "documentation": {}
    },
    {
        "label": "prepare_data_for_cohendz",
        "kind": 2,
        "importPath": "run_cohen_dz",
        "description": "run_cohen_dz",
        "peekOfCode": "def prepare_data_for_cohendz(category, time_window):\n    '''\n        Import data\n    '''\n    ERP_diff_category_region_window = prepare_data_diff(category)        \n    print(\"ERP_diff_category_region_window shape: \", ERP_diff_category_region_window.shape)\n    # Content accuracies\n    with open(f'decoding_data/word_class/{category}/word_class_all_accuracies.pkl', 'rb') as f:\n        content_accuracies = pickle.load(f)\n    # N400 window - Content words",
        "detail": "run_cohen_dz",
        "documentation": {}
    },
    {
        "label": "calculate_cohen_dz",
        "kind": 2,
        "importPath": "run_cohen_dz",
        "description": "run_cohen_dz",
        "peekOfCode": "def calculate_cohen_dz(data, chance):\n    # Step 1: Compute the mean difference\n    mean_diff = np.mean(data, axis=0) - chance\n    # Step 2: Calculate the standard deviation\n    std_diff = np.std(data, axis=0, ddof=1)\n    # Step 3: Compute Cohen's dz\n    dz = abs(mean_diff / std_diff)\n    #Note: Using rpTtest to get the same result\n    return dz\ndef run_bootstrap(data, N, state=42, confidence_level=0.95):",
        "detail": "run_cohen_dz",
        "documentation": {}
    },
    {
        "label": "run_bootstrap",
        "kind": 2,
        "importPath": "run_cohen_dz",
        "description": "run_cohen_dz",
        "peekOfCode": "def run_bootstrap(data, N, state=42, confidence_level=0.95):\n    # Set the random seed\n    np.random.seed(state)\n    # Bootstrap to calculate the 95% confidence intervals\n    n_bootstraps = N  # Number of bootstrap samples\n    # Bootstrap function to calculate the mean\n    def bootstrap_mean(data):\n        return np.mean(data)\n    # Perform bootstrapping\n    bootstrap_res = bootstrap(",
        "detail": "run_cohen_dz",
        "documentation": {}
    },
    {
        "label": "calculate_dz_for_viz",
        "kind": 2,
        "importPath": "run_cohen_dz",
        "description": "run_cohen_dz",
        "peekOfCode": "def calculate_dz_for_viz(ERP_diff, accuracies, chance_diff=0, chance_decoding=0.5, N=10000):\n    # For ERPs\n    n_subs = ERP_diff.shape[0]\n    N = 10000\n    cohen_dz_erp = []\n    for sub in range(n_subs):\n        # Step 1: Compute the difference wave for each subject\n        difference_wave = ERP_diff[sub]\n        # Calculate Cohen's dz\n        dz  = calculate_cohen_dz(difference_wave, chance=chance_diff)",
        "detail": "run_cohen_dz",
        "documentation": {}
    },
    {
        "label": "viz_cohen_dz",
        "kind": 2,
        "importPath": "run_cohen_dz",
        "description": "run_cohen_dz",
        "peekOfCode": "def viz_cohen_dz(bootstrap_mean_dz_erp, sem_dz_erp, bootstrap_mean_dz_decode, sem_dz_decode, ax, labels=['ERP', 'SVM']):\n    # Means and SEMs\n    means = [bootstrap_mean_dz_erp, bootstrap_mean_dz_decode]\n    sems = [sem_dz_erp, sem_dz_decode]\n    # Bar positions\n    x = np.arange(len(labels))\n    # Plot bars with error bars\n    bars = ax.bar(x, means, yerr=sems, capsize=10, color=['crimson', 'mediumseagreen'])\n    # Adding labels and title\n    ax.set_ylabel(\"Cohen's dz\", fontsize=25)",
        "detail": "run_cohen_dz",
        "documentation": {}
    },
    {
        "label": "sample_to_match_distribution",
        "kind": 2,
        "importPath": "run_preparation",
        "description": "run_preparation",
        "peekOfCode": "def sample_to_match_distribution(baseline, other_p_cloze, other_ids):\n    np.random.seed(42)  # For reproducibility\n    best_sample = None\n    best_ids = None\n    best_ks_stat = np.inf\n    sample_size = len(baseline)\n    for _ in tqdm(range(5000), position=0, leave=True):  # Number of iterations\n        indices = np.random.choice(len(other_p_cloze), sample_size, replace=False)\n        sample = other_p_cloze[indices]\n        ids = other_ids[indices]",
        "detail": "run_preparation",
        "documentation": {}
    },
    {
        "label": "convert_data_to_dict",
        "kind": 2,
        "importPath": "run_preparation",
        "description": "run_preparation",
        "peekOfCode": "def convert_data_to_dict():\n    \"\"\"\n    Converts EEG-based reading data into a dictionary: EEG data, metadata, and labels.\n    Parameters\n    ----------\n    data : \n    Returns\n    -------\n    dict\n        The dictionary of data.",
        "detail": "run_preparation",
        "documentation": {}
    },
    {
        "label": "prepare_data",
        "kind": 2,
        "importPath": "run_preparation",
        "description": "run_preparation",
        "peekOfCode": "def prepare_data(subjects_dict, subject_ids, word_type):\n    if word_type == 'content':\n        temp = CONTENT_TYPES\n    elif word_type == 'function':\n        temp = FUNCTION_TYPES\n    elif word_type in (CONTENT_TYPES + FUNCTION_TYPES):\n        # NOUN, VERB, ADJECTIVE, ADVERB, PRONOUN, ETC.\n        temp = [word_type] \n    else:\n        raise TypeError(\"Please enter a proper word type!\")",
        "detail": "run_preparation",
        "documentation": {}
    },
    {
        "label": "get_time_window",
        "kind": 2,
        "importPath": "run_raincloud",
        "description": "run_raincloud",
        "peekOfCode": "def get_time_window(start_idx, end_idx):\n    \"\"\"\n    Adjusts the given indices based on T_MIN, T_MAX, and INTERVALS.\n    Args:\n        start_idx (int): Start time window\n        end_idx (int):End time window\n        t_min (float): Minimum time value (e.g., -0.1).\n        t_max (float): Maximum time value (e.g., 0.5).\n        interval (float): Time interval step (e.g., 0.001).\n    Returns:",
        "detail": "run_raincloud",
        "documentation": {}
    },
    {
        "label": "prepare_data",
        "kind": 2,
        "importPath": "run_raincloud",
        "description": "run_raincloud",
        "peekOfCode": "def prepare_data(group, technique, time_window):\n    # Access the parameter values\n    type_mapping = {\n        'lexical_class': ['content', 'function'],\n        'content_group': ['NOUN', 'VERB'],\n        'function_group': ['DET', 'PRON']\n    }\n    regions = ['left_hemisphere', 'midlines', 'right_hemisphere']\n    word_type = type_mapping[group]\n    values = []",
        "detail": "run_raincloud",
        "documentation": {}
    }
]